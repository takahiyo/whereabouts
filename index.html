/** 在席表 同期API（JSONP） */
const PASSWORD       = 'NagoChu6261';
const ADMIN_PASSWORD = 'NagoChu6261';
const TOKEN_TTL_MS   = 60 * 60 * 1000;
const TOKEN_PREFIX   = 'tok_';
const CACHE_TTL_SEC  = 20;
const KEY_PREFIX     = 'presence:';
const DATA_KEY       = 'presence-board-default';
const CONFIG_KEY     = 'presence-config';
const ALLOWED_DATA_KEYS   = Object.freeze([DATA_KEY]);
const ALLOWED_CONFIG_KEYS = Object.freeze([CONFIG_KEY]);
const MAX_SET_BYTES       = 120 * 1024;
const RESET_DATA_ON_CONFIG_CHANGE = false;

function now(){ return Date.now(); }
function outJSONP(cb, obj){
  if(!/^[a-zA-Z0-9_.$]+$/.test(cb)) cb = 'callback';
  return ContentService.createTextOutput(cb + '(' + JSON.stringify(obj) + ')')
    .setMimeType(ContentService.MimeType.JAVASCRIPT);
}
function safeParam_(e, name, def){
  return (e && e.parameter && typeof e.parameter[name] === 'string') ? e.parameter[name] : def;
}
function checkToken_(prop, token){
  const exp = Number(prop.getProperty(TOKEN_PREFIX + token) || 0);
  return (exp && exp >= now());
}
function sweepTokens_(prop){
  if (Math.random() < 0.02) {
    const all = prop.getProperties(), t = now();
    for (var k in all) {
      if (k.indexOf(TOKEN_PREFIX) === 0) {
        var exp = Number(all[k] || 0);
        if (!exp || exp < t) prop.deleteProperty(k);
      }
    }
  }
}

/* === ID 生成 === */
function ensureMemberId_(member, seed, usedSet){
  if (member.id && /^[A-Za-z0-9_-]+$/.test(String(member.id)) && !usedSet.has(member.id)) {
    usedSet.add(member.id);
    return member.id;
  }
  const src = String(member.name||'') + '|' + String(member.ext||'') + '|' + String(seed||'');
  const hash = Utilities.computeDigest(
    Utilities.DigestAlgorithm.SHA_256,
    Utilities.newBlob(src).getBytes()
  );
  let n = 0;
  for (let i=0;i<6;i++){ n = (n * 256 + (hash[i] & 0xff)) >>> 0; }
  let pid = ('p' + n.toString(36)).slice(0,10);
  let cnt = 0;
  while (usedSet.has(pid)) { cnt++; pid = ('p' + n.toString(36) + cnt.toString(36)).slice(0,12); }
  member.id = pid;
  usedSet.add(pid);
  return pid;
}

/* 既定名簿 */
function defaultConfigV2(){
  return {
    version: 2,
    updated: now(),
    groups: [
      { title:"", members:[
        { name:"城間SV", ext:"108" }, { name:"清水", ext:"419" }, { name:"石垣", ext:"406" }, { name:"大島", ext:"426" },
        { name:"加藤", ext:"422" }, { name:"橋本", ext:"420" }, { name:"大石", ext:"423" }, { name:"田中", ext:"433" }, { name:"井山", ext:"427" },
      ]},
      { title:"", members:[
        { name:"近藤SV", ext:"111" }, { name:"飯島", ext:"415" }, { name:"永峯", ext:"429" }, { name:"溝", ext:"430" },
        { name:"山本", ext:"428" }, { name:"能登", ext:"410" }, { name:"松浦", ext:"414" }, { name:"長嶋", ext:"424" },
      ]},
      { title:"", members:[
        { name:"中村", ext:"301" }, { name:"吉田(拓)", ext:"306" }, { name:"阿部", ext:"302" }, { name:"若山", ext:"314" },
        { name:"平良", ext:"303" }, { name:"伊藤(楠)" }, { name:"平八重", ext:"313" }, { name:"竹森", ext:"307" },
      ]},
      { title:"", members:[
        { name:"村上", ext:"203" }, { name:"河内", ext:"208" }, { name:"林", ext:"211" }, { name:"鴫卯", ext:"201" },
        { name:"大井", ext:"206" }, { name:"高木SV", ext:"114" }, { name:"種口", ext:"209" },
      ]},
      { title:"", members:[
        { name:"鈴木", ext:"418" }, { name:"江畑", ext:"404" }, { name:"三島", ext:"410" }, { name:"中村(光)", ext:"412" },
        { name:"伊藤(尊)", ext:"425" }, { name:"古田(茂)", ext:"431" }, { name:"小川", ext:"432" },
      ]},
      { title:"", members:[
        { name:"小伊勢SV", ext:"109" }, { name:"今泉", ext:"413" }, { name:"村田", ext:"407" }, { name:"大野", ext:"411" },
        { name:"北村", ext:"400" }, { name:"長谷川", ext:"405" }, { name:"横内", ext:"421" },
      ]},
      { title:"", members:[
        { name:"石井SV", ext:"106" }, { name:"金村", ext:"402" }, { name:"井上", ext:"417" }, { name:"坪井", ext:"409" },
        { name:"折原", ext:"401" }, { name:"佐藤", ext:"403" }, { name:"水野", ext:"408" },
      ]},
      { title:"", members:[
        { name:"高羽", ext:"204" }, { name:"川崎", ext:"202" }, { name:"田中(あ)", ext:"200" }, { name:"小川Ⅱ", ext:"210" },
      ]},
      { title:"", members:[
        { name:"中村(幹)", ext:"309" }, { name:"三浦", ext:"300" }, { name:"稲葉", ext:"305" },
        { name:"伊藤(信)", ext:"315" }, { name:"小森", ext:"308" }, { name:"朝井", ext:"304" }, { name:"高橋B長", ext:"115" },
      ]},
      { title:"", members:[
        { name:"渡辺副所長", ext:"101" }, { name:"橋本EM", ext:"103" }, { name:"藤井SV", ext:"107" },
        { name:"猪野所長", ext:"100" }, { name:"日黒副所長", ext:"102" },
      ]},
    ]
  };
}

/* 旧形式→v2 + id付与 */
function normalizeConfig(json){
  let cfg;
  if (Array.isArray(json) && json.length && Array.isArray(json[0])) {
    cfg = { version:2, updated:now(), groups: json.map(arr=>({title:"", members:arr.map(name=>({name:String(name||'')}))})) };
  } else if (json && typeof json==='object' && Array.isArray(json.groups)) {
    cfg = {
      version:2, updated:(typeof json.updated==='number')?json.updated:now(),
      groups: json.groups.map(g=>({
        title: (g && typeof g.title==='string') ? g.title : "",
        members: Array.isArray(g?.members)? g.members.map(m=>({
          name:String(m?.name||''), ext:(m && m.ext)?String(m.ext):undefined, id:(m && m.id)?String(m.id):undefined
        })) : []
      }))
    };
  } else { cfg = defaultConfigV2(); }

  const used = new Set();
  cfg.groups.forEach((g,gi)=>g.members.forEach((m,mi)=>{
    if (m.id && /^[A-Za-z0-9_-]+$/.test(m.id)) { if (used.has(m.id)) m.id=undefined; }
    ensureMemberId_(m, `${gi}-${mi}`, used);
  }));
  return cfg;
}

function ensureConfig(){
  const prop = PropertiesService.getScriptProperties();
  if(!prop.getProperty(CONFIG_KEY)){
    prop.setProperty(CONFIG_KEY, JSON.stringify(defaultConfigV2()));
  }
}

/* === メイン: doGet === */
function doGet(e){
  const cb     = safeParam_(e,'callback','callback');
  const action = safeParam_(e,'action','get');
  const keyReq = safeParam_(e,'key','');
  const prop   = PropertiesService.getScriptProperties();
  const cache  = CacheService.getScriptCache();

  sweepTokens_(prop);
  ensureConfig();

  if (action==='login'){
    const pw = safeParam_(e,'password','');
    if (pw!==PASSWORD) return outJSONP(cb,{error:'unauthorized'});
    const token = Utilities.getUuid();
    prop.setProperty(TOKEN_PREFIX+token, String(now()+TOKEN_TTL_MS));
    return outJSONP(cb,{token:token, exp:TOKEN_TTL_MS});
  }

  if (action==='renew'){
    const token = safeParam_(e,'token','');
    if (!checkToken_(prop,token)) return outJSONP(cb,{error:'unauthorized'});
    prop.setProperty(TOKEN_PREFIX+token, String(now()+TOKEN_TTL_MS));
    return outJSONP(cb,{ok:true, exp:TOKEN_TTL_MS});
  }

  const token = safeParam_(e,'token','');
  if (!checkToken_(prop,token)) return outJSONP(cb,{error:'unauthorized'});

  if (action==='get'){
    const key     = ALLOWED_DATA_KEYS.includes(keyReq)? keyReq : DATA_KEY;
    const noCache = safeParam_(e,'nocache','')==='1';
    const cKey    = KEY_PREFIX + key;
    const hit     = noCache ? null : cache.get(cKey);
    if (hit){ try{ return outJSONP(cb, JSON.parse(hit)); }catch(err){} }
    const v = prop.getProperty(key) || '{"updated":0,"data":{}}';
    try { if (!noCache) cache.put(cKey, v, CACHE_TTL_SEC); return outJSONP(cb, JSON.parse(v)); }
    catch(err){ return outJSONP(cb,{updated:0,data:{}}); }
  }

  if (action==='set'){
    const key     = ALLOWED_DATA_KEYS.includes(keyReq)? keyReq : DATA_KEY;
    const dataRaw = safeParam_(e,'data','{"updated":0,"data":{}}');
    if (dataRaw && dataRaw.length>MAX_SET_BYTES) return outJSONP(cb,{error:'too_large'});
    try{
      const json = JSON.parse(dataRaw);
      if (!json || typeof json!=='object' || typeof json.updated!=='number' || typeof json.data!=='object')
        return outJSONP(cb,{error:'bad_data'});
    }catch(err){ return outJSONP(cb,{error:'bad_json'}); }
    const lock = LockService.getScriptLock();
    try{
      lock.tryLock(500);
      prop.setProperty(key, dataRaw);
      cache.put(KEY_PREFIX+key, dataRaw, CACHE_TTL_SEC);
      return outJSONP(cb,{ok:true});
    }finally{ try{ lock.releaseLock(); }catch(e2){} }
  }

  if (action==='getConfig'){
    const key     = ALLOWED_CONFIG_KEYS.includes(keyReq)? keyReq : CONFIG_KEY;
    const noCache = safeParam_(e,'nocache','')==='1';
    const cKey    = KEY_PREFIX + 'cfg:' + key;
    const hit     = noCache ? null : cache.get(cKey);
    if (hit){ try{ return outJSONP(cb, JSON.parse(hit)); }catch(err){} }
    const v = prop.getProperty(key);
    if (!v){
      const def = defaultConfigV2(); prop.setProperty(key, JSON.stringify(def));
      return outJSONP(cb, def);
    }
    try{
      const parsed = normalizeConfig(JSON.parse(v));
      if (typeof parsed.updated!=='number'){ parsed.updated=now(); prop.setProperty(key, JSON.stringify(parsed)); }
      const out = JSON.stringify(parsed);
      if (!noCache) cache.put(cKey, out, CACHE_TTL_SEC);
      return outJSONP(cb, parsed);
    }catch(err){
      const def = defaultConfigV2(); return outJSONP(cb, def);
    }
  }

  if (action==='setConfig'){
    const adminPw = safeParam_(e,'adminPw','');
    if (adminPw!==ADMIN_PASSWORD) return outJSONP(cb,{error:'forbidden'});
    const key     = ALLOWED_CONFIG_KEYS.includes(keyReq)? keyReq : CONFIG_KEY;
    const dataRaw = safeParam_(e,'data','');
    try{
      const json = normalizeConfig(JSON.parse(dataRaw));
      if (!json || !Array.isArray(json.groups)) throw new Error('bad');
      json.updated = now();
      const out = JSON.stringify(json);
      const lock = LockService.getScriptLock();
      try{
        lock.tryLock(500);
        prop.setProperty(key, out);
        if (RESET_DATA_ON_CONFIG_CHANGE){
          const empty = JSON.stringify({updated:0, data:{}});
          prop.setProperty(DATA_KEY, empty);
        }
        const cache = CacheService.getScriptCache();
        cache.put(KEY_PREFIX+'cfg:'+key, out, CACHE_TTL_SEC);
        cache.remove(KEY_PREFIX+DATA_KEY);
      }finally{ try{ lock.releaseLock(); }catch(e2){} }
      return outJSONP(cb,{ok:true});
    }catch(err){ return outJSONP(cb,{error:'bad_config'}); }
  }

  return outJSONP(cb,{error:'unknown_action'});
}

/* 管理ユーティリティ */
function exportConfigToLog(){ Logger.log(PropertiesService.getScriptProperties().getProperty(CONFIG_KEY) || '(no config)'); }
function importConfigFromString(jsonString){
  if (typeof jsonString!=='string' || !jsonString.trim()) throw new Error('jsonString required');
  const json = normalizeConfig(JSON.parse(jsonString)); json.updated = now();
  const prop = PropertiesService.getScriptProperties();
  prop.setProperty(CONFIG_KEY, JSON.stringify(json));
  flushConfigCache();
  if (RESET_DATA_ON_CONFIG_CHANGE){ prop.setProperty(DATA_KEY, JSON.stringify({updated:0, data:{}})); }
}
function setMemberIdByName(name,newId){
  if (!/^[\s\S]+$/.test(name)) throw new Error('name required');
  if (!/^[A-Za-z0-9_-]+$/.test(newId)) throw new Error('newId must be alnum/_-');
  const prop = PropertiesService.getScriptProperties();
  const v = prop.getProperty(CONFIG_KEY); if(!v) throw new Error('no config');
  const cfg = normalizeConfig(JSON.parse(v));
  let changed=false; const used=new Set(); cfg.groups.forEach(g=>g.members.forEach(m=>{if(m.id) used.add(m.id)}));
  for(const g of cfg.groups){ for(const m of g.members){ if(m.name===name){ if(used.has(newId)) throw new Error('newId already exists'); used.delete(m.id); m.id=newId; used.add(newId); changed=true; break; } } if(changed) break; }
  if(!changed) throw new Error('name not found');
  cfg.updated=now(); prop.setProperty(CONFIG_KEY, JSON.stringify(cfg)); flushConfigCache();
}
function renameMemberId(oldId,newId){
  if (!/^[A-Za-z0-9_-]+$/.test(oldId) || !/^[A-Za-z0-9_-]+$/.test(newId)) throw new Error('id invalid');
  const prop = PropertiesService.getScriptProperties(); const v=prop.getProperty(CONFIG_KEY); if(!v) throw new Error('no config');
  const cfg=normalizeConfig(JSON.parse(v)); const used=new Set(); let found=false;
  cfg.groups.forEach(g=>g.members.forEach(m=>{if(m.id) used.add(m.id)})); if(used.has(newId)) throw new Error('newId already exists');
  for(const g of cfg.groups){ for(const m of g.members){ if(m.id===oldId){ m.id=newId; found=true; break; } } if(found) break; }
  if(!found) throw new Error('oldId not found'); cfg.updated=now(); prop.setProperty(CONFIG_KEY, JSON.stringify(cfg)); flushConfigCache();
}
function flushConfigCache(){
  const cache = CacheService.getScriptCache();
  cache.remove(KEY_PREFIX+'cfg:'+CONFIG_KEY);
  cache.remove(KEY_PREFIX+DATA_KEY);
}
function resetConfigToDefault(){
  const prop = PropertiesService.getScriptProperties();
  const cfg  = normalizeConfig(defaultConfigV2());
  cfg.updated = Date.now();
  prop.setProperty(CONFIG_KEY, JSON.stringify(cfg));
  flushConfigCache();
}
