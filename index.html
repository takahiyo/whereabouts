/** 在席表 同期API（JSONP） - 拠点ごとにキー分割（簡易マルチテナント） */

// === 拠点定義（必要に応じて追加） ===
const OFFICES = Object.freeze({
  nagoya: { name: '名古屋中央営業所', password: 'NagoChu6261', adminPassword: 'NagoChu6261' },
  test:   { name: 'テスト',             password: 'test123',     adminPassword: 'test123'     },
});

const TOKEN_TTL_MS   = 60 * 60 * 1000;
const TOKEN_PREFIX   = 'tok_';
const TOKEN_OFFICE_PREFIX = 'toff_';
const CACHE_TTL_SEC  = 20;
const KEY_PREFIX     = 'presence:';  // for Cache keys
const MAX_SET_BYTES  = 120 * 1024;
const RESET_DATA_ON_CONFIG_CHANGE = false;

function now(){ return Date.now(); }
function outJSONP(cb, obj){
  if(!/^[a-zA-Z0-9_.$]+$/.test(cb)) cb = 'callback';
  return ContentService.createTextOutput(cb + '(' + JSON.stringify(obj) + ')')
    .setMimeType(ContentService.MimeType.JAVASCRIPT);
}
function safeParam_(e, name, def){
  return (e && e.parameter && typeof e.parameter[name] === 'string') ? e.parameter[name] : def;
}
function checkToken_(prop, token){
  const exp = Number(prop.getProperty(TOKEN_PREFIX + token) || 0);
  return (exp && exp >= now());
}
function getOfficeByToken_(prop, token){
  const office = prop.getProperty(TOKEN_OFFICE_PREFIX + token);
  if (!office || !OFFICES[office]) return null;
  return office;
}
function sweepTokens_(prop){
  if (Math.random() < 0.02) {
    const all = prop.getProperties(), t = now();
    for (var k in all) {
      if (k.indexOf(TOKEN_PREFIX) === 0) {
        var exp = Number(all[k] || 0);
        if (!exp || exp < t) {
          const token = k.substring(TOKEN_PREFIX.length);
          prop.deleteProperty(k);
          prop.deleteProperty(TOKEN_OFFICE_PREFIX + token);
        }
      }
    }
  }
}

// === キー算出（拠点ごと） ===
function dataKeyForOffice_(office){ return `presence-board-${office}`; }
function configKeyForOffice_(office){ return `presence-config-${office}`; }

// === ID 生成 ===
function ensureMemberId_(member, seed, usedSet){
  if (member.id && /^[A-Za-z0-9_-]+$/.test(String(member.id)) && !usedSet.has(member.id)) {
    usedSet.add(member.id);
    return member.id;
  }
  const src = String(member.name||'') + '|' + String(member.ext||'') + '|' + String(seed||'');
  const hash = Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, Utilities.newBlob(src).getBytes());
  let n = 0;
  for (let i=0;i<6;i++){ n = (n * 256 + (hash[i] & 0xff)) >>> 0; }
  let pid = ('p' + n.toString(36)).slice(0,10);
  let cnt = 0;
  while (usedSet.has(pid)) { cnt++; pid = ('p' + n.toString(36) + cnt.toString(36)).slice(0,12); }
  member.id = pid;
  usedSet.add(pid);
  return pid;
}

// === 既定名簿（名古屋） ===
function defaultConfigNagoya_(){
  return {
    version: 2,
    updated: now(),
    groups: [
      { title:"", members:[
        { name:"城間SV", ext:"108" }, 
        { name:"清水", ext:"419" }, { name:"石垣", ext:"406" }, { name:"大島", ext:"426" }, { name:"加藤", ext:"422" }, 
        { name:"橋本", ext:"420" }, { name:"大石", ext:"423" }, { name:"田中", ext:"433" }, { name:"井山", ext:"427" },
      ]},
      { title:"", members:[
        { name:"近藤SV", ext:"111" }, 
        { name:"飯島", ext:"415" }, { name:"永峯", ext:"429" }, { name:"蒲", ext:"430" }, { name:"山本", ext:"428" }, 
        { name:"能登", ext:"410" }, { name:"松浦", ext:"414" }, { name:"長縄", ext:"424" },
      ]},
      { title:"", members:[
        { name:"鈴木", ext:"418" }, { name:"江場", ext:"404" }, { name:"三島", ext:"410" }, 
        { name:"中村(亮)", ext:"412" }, { name:"伊藤(尊)", ext:"425" }, { name:"古田(茂)", ext:"431" }, { name:"小川", ext:"432" },
      ]},
      { title:"", members:[
        { name:"小伊勢SV", ext:"109" }, 
        { name:"今泉", ext:"413" }, { name:"村田", ext:"407" }, { name:"大野", ext:"411" },
        { name:"北村", ext:"400" }, { name:"長谷川", ext:"405" }, { name:"横内", ext:"421" },
      ]},
      { title:"", members:[
        { name:"石井SV", ext:"106" }, 
        { name:"金村", ext:"402" }, { name:"井上", ext:"417" }, { name:"坪井", ext:"409" },
        { name:"折原", ext:"401" }, { name:"佐藤", ext:"403" }, { name:"水野", ext:"408" },
      ]},
      { title:"", members:[
        { name:"高橋B長", ext:"115" },
        { name:"中村(純)", ext:"309" }, { name:"稲葉", ext:"305" }, { name:"小森", ext:"308" },
        { name:"三浦", ext:"300" }, { name:"伊藤(信)", ext:"315" }, { name:"朝井", ext:"304" },
      ]},
      { title:"", members:[
        { name:"中村", ext:"301" }, { name:"阿部", ext:"302" }, { name:"平良", ext:"303" }, { name:"平八重", ext:"313", id:"2379862" },
        { name:"吉田(拓)", ext:"306" }, { name:"若山", ext:"314" }, { name:"伊藤(樹)" }, { name:"竹森", ext:"307" },
      ]},
      { title:"", members:[
        { name:"高木SV", ext:"114" },
        { name:"村上", ext:"203" }, { name:"河内", ext:"208" }, { name:"鵜飼", ext:"201" },
        { name:"林", ext:"211" }, { name:"大井", ext:"206" }, { name:"樋口", ext:"209" },
      ]},
      { title:"", members:[
        { name:"高羽", ext:"204" }, { name:"川崎", ext:"202" }, 
        { name:"田中(あ)", ext:"200" }, { name:"小川", ext:"210" },
      ]},
      { title:"", members:[
        { name:"猪野所長", ext:"100" }, 
        { name:"渡辺副所長", ext:"101" }, { name:"日黒副所長", ext:"102" }, { name:"嶋本EM", ext:"103" }, { name:"藤井SV", ext:"107" }, 
      ]},
    ]
  };
}

// === 既定名簿（テスト拠点） ===
function defaultConfigTest_(){
  return {
    version: 2,
    updated: now(),
    groups: [
      { title:"テスト1", members:[ { name:"test1さん" } ] },
      { title:"テスト2", members:[ { name:"test2さん" } ] },
    ]
  };
}

// 旧形式→v2 + id付与
function normalizeConfig(json){
  let cfg;
  if (Array.isArray(json) && json.length && Array.isArray(json[0])) {
    cfg = { version:2, updated:now(), groups: json.map(arr=>({title:"", members:arr.map(name=>({name:String(name||'')}))})) };
  } else if (json && typeof json==='object' && Array.isArray(json.groups)) {
    cfg = {
      version:2, updated:(typeof json.updated==='number')?json.updated:now(),
      groups: json.groups.map(g=>({
        title: (g && typeof g.title==='string') ? g.title : "",
        members: Array.isArray(g?.members)? g.members.map(m=>({
          name:String(m?.name||''), ext:(m && m.ext)?String(m.ext):undefined, id:(m && m.id)?String(m.id):undefined
        })) : []
      }))
    };
  } else { cfg = {version:2, updated:now(), groups:[]}; }

  const used = new Set();
  cfg.groups.forEach((g,gi)=>g.members.forEach((m,mi)=>{
    if (m.id && /^[A-Za-z0-9_-]+$/.test(m.id)) { if (used.has(m.id)) m.id=undefined; }
    ensureMemberId_(m, `${gi}-${mi}`, used);
  }));
  return cfg;
}

// 初期構成の保証（全拠点）
function ensureConfigAll_(){
  const prop = PropertiesService.getScriptProperties();
  Object.keys(OFFICES).forEach(office=>{
    const cfgKey = configKeyForOffice_(office);
    if(!prop.getProperty(cfgKey)){
      const base = office==='nagoya' ? defaultConfigNagoya_() : defaultConfigTest_();
      const def = normalizeConfig(base);
      prop.setProperty(cfgKey, JSON.stringify(def));
    }
  });
}

/* === メイン: doGet === */
function doGet(e){
  const cb     = safeParam_(e,'callback','callback');
  const action = safeParam_(e,'action','get');
  const prop   = PropertiesService.getScriptProperties();
  const cache  = CacheService.getScriptCache();

  sweepTokens_(prop);
  ensureConfigAll_();

  // --- login（拠点＋PW） ---
  if (action==='login'){
    const office = safeParam_(e,'office','');
    const pw = safeParam_(e,'password','');
    if (!OFFICES[office] || pw !== OFFICES[office].password) return outJSONP(cb,{error:'unauthorized'});
    const token = Utilities.getUuid();
    prop.setProperty(TOKEN_PREFIX+token, String(now()+TOKEN_TTL_MS));
    prop.setProperty(TOKEN_OFFICE_PREFIX+token, office);
    return outJSONP(cb,{token:token, exp:TOKEN_TTL_MS, office:office, officeName:OFFICES[office].name});
  }

  // --- renew ---
  if (action==='renew'){
    const token = safeParam_(e,'token','');
    if (!checkToken_(prop,token)) return outJSONP(cb,{error:'unauthorized'});
    prop.setProperty(TOKEN_PREFIX+token, String(now()+TOKEN_TTL_MS));
    return outJSONP(cb,{ok:true, exp:TOKEN_TTL_MS});
  }

  // 認証必須以降
  const token = safeParam_(e,'token','');
  if (!checkToken_(prop,token)) return outJSONP(cb,{error:'unauthorized'});
  const office = getOfficeByToken_(prop, token);
  if (!office) return outJSONP(cb,{error:'unauthorized'});

  const DATA_KEY   = dataKeyForOffice_(office);
  const CONFIG_KEY = configKeyForOffice_(office);

  if (action==='get'){
    const noCache = safeParam_(e,'nocache','')==='1';
    const cKey    = KEY_PREFIX + 'data:' + office;
    const hit     = noCache ? null : cache.get(cKey);
    if (hit){ try{ return outJSONP(cb, JSON.parse(hit)); }catch(err){} }
    const v = prop.getProperty(DATA_KEY) || '{"updated":0,"data":{}}';
    try { if (!noCache) cache.put(cKey, v, CACHE_TTL_SEC); return outJSONP(cb, JSON.parse(v)); }
    catch(err){ return outJSONP(cb,{updated:0,data:{}}); }
  }

  if (action==='set'){
    const dataRaw = safeParam_(e,'data','{"updated":0,"data":{}}');
    if (dataRaw && dataRaw.length>MAX_SET_BYTES) return outJSONP(cb,{error:'too_large'});

    let incoming;
    try{
      incoming = JSON.parse(dataRaw);
      if (!incoming || typeof incoming!=='object' || typeof incoming.updated!=='number' || typeof incoming.data!=='object')
        return outJSONP(cb,{error:'bad_data'});
    }catch(err){ return outJSONP(cb,{error:'bad_json'}); }

    const lock = LockService.getScriptLock();
    try{
      lock.tryLock(500);

      const prevRaw = prop.getProperty(DATA_KEY) || '{"updated":0,"data":{}}';
      let prev; try{ prev = JSON.parse(prevRaw); }catch(_){ prev = {updated:0,data:{}}; }

      let out;
      if (incoming.full === true) {
        out = { updated: incoming.updated || now(), data: incoming.data || {} };
      } else {
        const merged = Object.assign({}, prev.data || {});
        for (var k in incoming.data) merged[k] = incoming.data[k];
        out = { updated: Math.max(Number(prev.updated)||0, Number(incoming.updated)||0, now()), data: merged };
      }

      const outStr = JSON.stringify(out);
      prop.setProperty(DATA_KEY, outStr);
      cache.put(KEY_PREFIX+'data:'+office, outStr, CACHE_TTL_SEC);
      return outJSONP(cb,{ok:true});
    } finally {
      try{ lock.releaseLock(); }catch(e2){}
    }
  }

  if (action==='getConfig'){
    const noCache = safeParam_(e,'nocache','')==='1';
    const cKey    = KEY_PREFIX + 'cfg:' + office;
    const hit     = noCache ? null : cache.get(cKey);
    if (hit){ try{ return outJSONP(cb, JSON.parse(hit)); }catch(err){} }
    const v = prop.getProperty(CONFIG_KEY);
    let parsed;
    try{
      parsed = normalizeConfig(JSON.parse(v));
    }catch(err){
      parsed = normalizeConfig(office==='nagoya'? defaultConfigNagoya_() : defaultConfigTest_());
    }
    parsed.updated = typeof parsed.updated==='number' ? parsed.updated : now();
    const out = JSON.stringify(parsed);
    prop.setProperty(CONFIG_KEY, out);
    if (!noCache) cache.put(cKey, out, CACHE_TTL_SEC);
    return outJSONP(cb, parsed);
  }

  if (action==='setConfig'){
    const adminPw = safeParam_(e,'adminPw','');
    if (adminPw!==OFFICES[office].adminPassword) return outJSONP(cb,{error:'forbidden'});
    const dataRaw = safeParam_(e,'data','');
    try{
      const json = normalizeConfig(JSON.parse(dataRaw));
      if (!json || !Array.isArray(json.groups)) throw new Error('bad');
      json.updated = now();
      const out = JSON.stringify(json);
      const lock = LockService.getScriptLock();
      try{
        lock.tryLock(500);
        prop.setProperty(CONFIG_KEY, out);
        if (RESET_DATA_ON_CONFIG_CHANGE){
          const empty = JSON.stringify({updated:0, data:{}});
          prop.setProperty(DATA_KEY, empty);
        }
        cache.put(KEY_PREFIX+'cfg:'+office, out, CACHE_TTL_SEC);
        cache.remove(KEY_PREFIX+'data:'+office);
      }finally{ try{ lock.releaseLock(); }catch(e2){} }
      return outJSONP(cb,{ok:true});
    }catch(err){ return outJSONP(cb,{error:'bad_config'}); }
  }

  if (action==='clearData'){
    const adminPw = safeParam_(e,'adminPw','');
    if (adminPw!==OFFICES[office].adminPassword) return outJSONP(cb,{error:'forbidden'});
    const empty = JSON.stringify({updated:0, data:{}});
    prop.setProperty(DATA_KEY, empty);
    CacheService.getScriptCache().remove(KEY_PREFIX + 'data:' + office);
    return outJSONP(cb,{ok:true});
  }

  return outJSONP(cb,{error:'unknown_action'});
}

/* 管理ユーティリティ */
function exportConfigToLog(office){
  const k = configKeyForOffice_(office||'nagoya');
  Logger.log(PropertiesService.getScriptProperties().getProperty(k) || '(no config)');
}
function importConfigFromString(jsonString, office){
  if (typeof jsonString!=='string' || !jsonString.trim()) throw new Error('jsonString required');
  const o = office||'nagoya';
  const json = normalizeConfig(JSON.parse(jsonString)); json.updated = now();
  const prop = PropertiesService.getScriptProperties();
  prop.setProperty(configKeyForOffice_(o), JSON.stringify(json));
  flushConfigCache(o);
  if (RESET_DATA_ON_CONFIG_CHANGE){ prop.setProperty(dataKeyForOffice_(o), JSON.stringify({updated:0, data:{}})); }
}
function setMemberIdByName(name,newId,office){
  if (!/^[\s\S]+$/.test(name)) throw new Error('name required');
  if (!/^[A-Za-z0-9_-]+$/.test(newId)) throw new Error('newId must be alnum/_-');
  const o = office||'nagoya';
  const prop = PropertiesService.getScriptProperties();
  const v = prop.getProperty(configKeyForOffice_(o)); if(!v) throw new Error('no config');
  const cfg = normalizeConfig(JSON.parse(v));
  let changed=false; const used=new Set(); cfg.groups.forEach(g=>g.members.forEach(m=>{if(m.id) used.add(m.id)}));
  for(const g of cfg.groups){ for(const m of g.members){ if(m.name===name){ if(used.has(newId)) throw new Error('newId already exists'); used.delete(m.id); m.id=newId; used.add(newId); changed=true; break; } } if(changed) break; }
  if(!changed) throw new Error('name not found');
  cfg.updated=now(); prop.setProperty(configKeyForOffice_(o), JSON.stringify(cfg)); flushConfigCache(o);
}
function renameMemberId(oldId,newId,office){
  if (!/^[A-Za-z0-9_-]+$/.test(oldId) || !/^[A-Za-z0-9_-]+$/.test(newId)) throw new Error('id invalid');
  const o = office||'nagoya';
  const prop = PropertiesService.getScriptProperties(); const v=prop.getProperty(configKeyForOffice_(o)); if(!v) throw new Error('no config');
  const cfg=normalizeConfig(JSON.parse(v)); const used=new Set(); let found=false;
  cfg.groups.forEach(g=>g.members.forEach(m=>{if(m.id) used.add(m.id)})); if(used.has(newId)) throw new Error('newId already exists');
  for(const g of cfg.groups){ for(const m of g.members){ if(m.id===oldId){ m.id=newId; found=true; break; } } if(found) break; }
  if(!found) throw new Error('oldId not found'); cfg.updated=now(); prop.setProperty(configKeyForOffice_(o), JSON.stringify(cfg)); flushConfigCache(o);
}
function flushConfigCache(office){
  const cache = CacheService.getScriptCache();
  const o = office||'nagoya';
  cache.remove(KEY_PREFIX+'cfg:'+o);
  cache.remove(KEY_PREFIX+'data:'+o);
}
function resetConfigToDefault(office){
  const o = office||'nagoya';
  const prop = PropertiesService.getScriptProperties();
  const cfg  = normalizeConfig(o==='nagoya'? defaultConfigNagoya_() : defaultConfigTest_());
  cfg.updated = Date.now();
  prop.setProperty(configKeyForOffice_(o), JSON.stringify(cfg));
  flushConfigCache(o);
}
function clearPresenceData(office){
  const o = office||'nagoya';
  const p = PropertiesService.getScriptProperties();
  p.setProperty(dataKeyForOffice_(o), JSON.stringify({updated:0, data:{}}));
  CacheService.getScriptCache().remove(KEY_PREFIX + 'data:' + o);
}
function dumpPresenceData(office){
  const o = office||'nagoya';
  const raw = PropertiesService.getScriptProperties().getProperty(dataKeyForOffice_(o));
  Logger.log(raw || '(empty)');
}
