<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>在席確認表</title>
<style>
  /* =========================================
   * 幅・サイズの集中定義（ここだけ触ればOK）
   * ========================================= */
  :root{
    /* 基準幅（px） */
    --base-name:   120px;  /* 氏名 */
    --base-ext:     80px;  /* 内線 */
    --base-status: 380px;  /* ステータス */
    --base-time:   120px;  /* 戻り時間 */
    --base-note:   320px;  /* 備考 */

    /* 倍率 */
    --scale-name:   0.50;
    --scale-ext:    0.33;
    --scale-status: 0.75;
    --scale-time:   0.45;

    /* 安全最小幅 */
    --min-name:    90px;
    --min-ext:     64px;
    --min-status: 260px;
    --min-time:   100px;
    --min-note:   260px;

    /* 実効幅（最終列幅） */
    --w-name:   max(calc(var(--base-name)   * var(--scale-name)),   var(--min-name));
    --w-ext:    max(calc(var(--base-ext)    * var(--scale-ext)),    var(--min-ext));
    --w-status: max(calc(var(--base-status) * var(--scale-status)), var(--min-status));
    --w-time:   max(calc(var(--base-time)   * var(--scale-time)),   var(--min-time));
    --w-note:   max(var(--base-note), var(--min-note));

    /* パネル最小幅：列合計 + 余白 */
    --panel-min: calc(var(--w-name) + var(--w-ext) + var(--w-status) + var(--w-time) + var(--w-note) + 60px);

    --gap: 20px;

    /* 色 */
    --line:#d9d9d9; --head:#f1ece6; --bg:#fafafa;
    --present:#e8f6e8; --away:#fff3e6; --remote:#e8f0ff; --off:#f7e8ee; --home:#ffe8f0;
  }

  @media (max-width: 768px){
    :root{
      --min-name:   90px;
      --min-ext:    64px;
      --min-status: 280px;
      --min-time:   110px;
      --min-note:   240px;
      --w-name:   var(--min-name);
      --w-ext:    var(--min-ext);
      --w-status: var(--min-status);
      --w-time:   var(--min-time);
      --w-note:   var(--min-note);
      --panel-min: calc(var(--w-name) + var(--w-ext) + var(--w-status) + var(--w-time) + var(--w-note) + 40px);
      --gap: 12px;
    }
    /* iOSズーム防止 */
    select, input{ font-size:16px; }
  }

  body{font-family:"Segoe UI","Hiragino Kaku Gothic ProN",Meiryo,sans-serif;background:#fff;margin:16px}
  header{display:flex;gap:8px;align-items:center;justify-content:center;margin-bottom:12px;flex-wrap:wrap}
  header h1{font-size:14px;font-weight:600;color:#4a5568;margin:0;padding:.35rem .9rem;background:#dff1ff;border-radius:999px}
  .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}

  /* パネルは1枚なら横幅いっぱいでOK：元の挙動を維持 */
  .board{
    display:grid;
    grid-template-columns: repeat(auto-fit, minmax(var(--panel-min), 1fr));
    gap: var(--gap);
  }

  .panel{border:1px solid var(--line);border-radius:6px;background:var(--bg);padding:8px;overflow:auto}
  .panel .title{font-weight:700;color:#6B7280;background:#f7f7f7;border:1px solid var(--line);
                border-radius:4px;padding:6px 8px;margin:0 0 6px 0;min-height:1.8em}

  table{width:100%;border-collapse:separate;border-spacing:0;table-layout:fixed}
  thead th{position:sticky;top:0;background:var(--head);font-weight:700}
  th,td{border:1px solid var(--line);padding:6px;font-size:14px}
  th{text-align:left}

  /* 列幅 */
  col.col-name   { width: var(--w-name); }
  col.col-ext    { width: var(--w-ext); }
  col.col-status { width: var(--w-status); }
  col.col-time   { width: var(--w-time); }
  col.col-note   { width: var(--w-note); }

  /* 入力UI */
  select,input[type="text"]{
    width:100%;box-sizing:border-box;padding:.3rem .35rem;border:1px solid var(--line);
    border-radius:4px;background:#fff;font-size:14px;appearance:auto;-webkit-appearance:auto
  }
  /* ▼重なり対策（仕様値） */
  td.status select{ padding-right:2.6em; }
  /* ステータス列の最小幅（列変数と13emの大きい方） */
  td.status{ min-width: max(var(--w-status), 13em); }

  /* 戻り時間：中央寄せ＆タブラー数字 */
  td.time select{ text-align-last:center; font-variant-numeric:tabular-nums; }

  /* ステータス色 */
  tr[data-status="在席"]{background:var(--present)}
  tr[data-status="外出"]{background:var(--away)}
  tr[data-status="休み"],tr[data-status="健康診断"],tr[data-status="コアドック"]{background:var(--off)}
  tr[data-status="帰宅"]{background:var(--home)}
  tr[data-status="在宅勤務"]{background:var(--remote)}
  tr[data-status="出張"],tr[data-status="研修"]{background:var(--away)}

  .toast{position:fixed;top:20px;right:20px;background:#333;color:#fff;padding:8px 12px;border-radius:4px;font-size:12px;opacity:0;transition:.25s;z-index:9999}
  .toast.show{opacity:1}

  .login{position:fixed;inset:0;background:rgba(0,0,0,.6);display:flex;align-items:center;justify-content:center;z-index:2000}
  .login .card{background:#fff;border-radius:8px;padding:20px;min-width:300px;max-width:90vw;text-align:center}
  .login .card h2{margin:.2rem 0 1rem}
  .login .card input{margin:.4rem 0}

  @media print{
    header,.toast,.login{display:none}
    body{margin:0}
    .board{gap:10px}
    th,td{font-size:12px;padding:4px}
  }

  /* 拡張のハンドル抑止 */
  .board [draggable], .board [role="separator"]{ display:none !important; }
</style>
</head>
<body>
  <header>
    <h1>在席確認表（同期対応）</h1>
  </header>

  <!-- ログイン（成功までは表を生成しない） -->
  <div id="login" class="login" style="display:none">
    <div class="card">
      <h2>在席確認表</h2>
      <p>パスワードを入力してください</p>
      <input type="password" id="pw" placeholder="Password" />
      <button id="btnLogin" onclick="window.__doLogin && window.__doLogin()">ログイン</button>
      <div id="loginMsg" style="color:#c53030;margin-top:8px" aria-live="polite"></div>
    </div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>
  <!-- ログイン後に初めて描画 -->
  <div id="board" class="board" style="display:none"></div>

<script>
/* ============================================================
 *  同期設定（JSONP / GASトークン認証）
 * ============================================================ */
const REMOTE_ENDPOINT = "https://script.google.com/macros/s/AKfycbwE49X_ppiNL_zLythtkR3pTeS4AsTzQKrn0DbQlo3Gvav3tOH3FUxh395bhk3oyMJ0/exec";
const REMOTE_KEY      = "presence-board-default";

/* ポーリング（在席：30s、設定：120s） */
const REMOTE_POLL_MS   = 30000;    // 在席データpull：30秒
const CONFIG_POLL_MS   = 120000;   // 設定データpull：2分（updated監視）
const SESSION_KEY      = "presence-session-token";

/* トークン更新：TTLの80%時点でrenew */
const TOKEN_DEFAULT_TTL = 3600000; // 60分（GAS側がexpを返さない場合の保険）
let tokenRenewTimer = null;

/* ============================================================
 *  名簿・グループ（GASから取得：人IDキー運用）
 * ============================================================ */
let GROUPS = [];        // サーバの presence-config をロード
let CONFIG_UPDATED = 0; // サーバの updated 値を保持（自動更新判定）

/* 旧/新形式をクライアント側で正規化（idはサーバ保証。無ければフォールバック生成） */
function normalizeConfigClient(cfg){
  // 旧形式: [ ["村田","今泉"], ... ]
  if(Array.isArray(cfg) && cfg.length && Array.isArray(cfg[0])){
    return cfg.map(arr=>({ title:"", members: arr.map(n=>({name:String(n||""), id:makeLocalId(String(n||""))})) }));
  }
  // v2形式
  if(cfg && Array.isArray(cfg.groups)){
    return cfg.groups.map(g=>({
      title: typeof g.title==="string" ? g.title : "",
      members: Array.isArray(g.members) ? g.members.map(m=>{
        const name = String((m && m.name) || "");
        const ext  = (m && m.ext) ? String(m.ext) : "";
        let id     = (m && m.id) ? String(m.id) : "";
        if(!/^[A-Za-z0-9]+$/.test(id)){ id = makeLocalId(name+ext); } // 念のため
        return { name, ext, id };
      }) : []
    }));
  }
  return [];
}

/* ローカルID（フォールバック用：英数字のみ） */
function makeLocalId(s){
  const seed = (s||"").normalize('NFKC').replace(/\s+/g,'');
  // 簡易ハッシュ（英数字に限定）
  let h = 0; for(let i=0;i<seed.length;i++){ h = (h*31 + seed.charCodeAt(i)) >>> 0; }
  return "P" + (h.toString(16) + "00000000").slice(0,8);
}

/* ============================================================
 *  定数
 * ============================================================ */
const STATUSES = ["在席","外出","休み","帰宅","在宅勤務","出張","研修","健康診断","コアドック"];
const CLEAR_ON = new Set(["在席","休み","帰宅","在宅勤務"]);   // 選択で戻り/備考をクリア
const storeKey = "presence-board-v3";   // ★人IDキー運用のローカル保存バージョン

/* ============================================================
 *  レンダリング
 * ============================================================ */
const board  = document.getElementById('board');
const toastEl= document.getElementById('toast');

function timeOptions(){
  const opts=['<option value=""></option>'];
  for(let h=0;h<24;h++){
    for(let m=0;m<60;m+=30){
      const t=`${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
      opts.push(`<option value="${t}">${t}</option>`);
    }
  }
  return opts.join('');
}

function rowHtml(gIndex, rIndex, member){
  const m   = (typeof member === 'string') ? {name: member} : (member || {});
  const name= m.name || "";
  const ext = (m.ext && /^[0-9]{1,4}$/.test(String(m.ext))) ? String(m.ext) : "";
  const id  = m.id && /^[A-Za-z0-9]+$/.test(m.id) ? m.id : makeLocalId(name+ext);
  const key = id;
  return `
    <tr id="row-${key}" data-key="${key}" data-status="在席">
      <td class="name">${name}</td>
      <td class="ext">
        <label class="sr-only" for="ext-${key}">内線</label>
        <input id="ext-${key}" name="ext" type="text" maxlength="4"
               inputmode="numeric" pattern="^[0-9]{0,4}$" placeholder="内線"
               value="${ext}" />
      </td>
      <td class="status">
        <label class="sr-only" for="status-${key}">ステータス</label>
        <select id="status-${key}" name="status">
          ${STATUSES.map(s=>`<option value="${s}">${s}</option>`).join("")}
        </select>
      </td>
      <td class="time">
        <label class="sr-only" for="time-${key}">戻り時間</label>
        <select id="time-${key}" name="time">${timeOptions()}</select>
      </td>
      <td class="note">
        <input id="note-${key}" name="note" type="text" list="noteOptions" placeholder="備考" />
      </td>
    </tr>`;
}

function panelHtml(gIndex, group){
  return `
    <section class="panel">
      <h3 class="title">${group.title ?? ""}</h3>
      <table aria-label="在席表">
        <colgroup>
          <col class="col-name">
          <col class="col-ext">
          <col class="col-status">
          <col class="col-time">
          <col class="col-note">
        </colgroup>
        <thead>
          <tr><th>氏名</th><th>内線</th><th>ステータス</th><th>戻り時間</th><th>備考</th></tr>
        </thead>
        <tbody>${group.members.map((m,i)=>rowHtml(gIndex,i,m)).join("")}</tbody>
      </table>
    </section>`;
}

function render(){
  board.innerHTML = GROUPS.map((g,i)=>panelHtml(i,g)).join('');
  board.style.display = '';   // ログイン後に表示
  wireEvents();
  loadLocal();  // 端末ローカルの前回値を適用（人IDキー）
  recolor();
}

/* ============================================================
 *  状態 I/O（人IDキー）
 * ============================================================ */
function getState(){
  const data={};
  board.querySelectorAll("tbody tr").forEach(tr=>{
    const k=tr.dataset.key;
    data[k]={
      ext:    tr.querySelector('input[name="ext"]').value.trim(),
      status: tr.querySelector('select[name="status"]').value,
      time:   tr.querySelector('select[name="time"]').value,
      note:   tr.querySelector('input[name="note"]').value
    };
  });
  return data;
}

/* 送信用：既定(在席/空欄)は送らない */
function getStateForPush(){
  const full=getState(), slim={};
  for(const [k,v] of Object.entries(full)){
    if(v.ext || v.status!=="在席" || v.time || (v.note && v.note.trim()!=="")) slim[k]=v;
  }
  return slim;
}

function applyState(data){
  if(!data) return;
  Object.entries(data).forEach(([k,v])=>{
    const e=document.getElementById(`ext-${k}`);
    const s=document.getElementById(`status-${k}`);
    const t=document.getElementById(`time-${k}`);
    const n=document.getElementById(`note-${k}`);
    if(e && typeof v.ext==="string") e.value = v.ext;
    if(s && v.status && STATUSES.includes(v.status)) s.value=v.status;
    if(t) t.value = v.time || "";
    if(n) n.value = v.note || "";
    if(s && t) toggleTimeEnable(s);
  });
  recolor();
}

function saveLocal(){ try{ localStorage.setItem(storeKey, JSON.stringify(getState())); toast('保存しました'); }catch(_){} }
function loadLocal(){ try{ const raw=localStorage.getItem(storeKey); if(!raw) return; applyState(JSON.parse(raw)); }catch(_){} }

/* ============================================================
 *  イベント
 * ============================================================ */
function wireEvents(){
  board.querySelectorAll("select,input").forEach(el=>{
    el.addEventListener("change", ()=>{
      if(el.name==="status"){
        const key = el.id.replace("status-","");
        const time = document.getElementById(`time-${key}`);
        const note = document.getElementById(`note-${key}`);
        if(CLEAR_ON.has(el.value)){
          if(time){ time.value=""; }
          if(note){ note.value=""; }
        }
        toggleTimeEnable(el);
      }
      saveLocal(); pushRemoteThrottled();
      recolor();
    });
  });
}

function toggleTimeEnable(statusEl){
  const key = statusEl.id.replace("status-","");
  const timeEl = document.getElementById(`time-${key}`);
  const needsTime = ["外出","出張","研修"].includes(statusEl.value);
  if(timeEl){
    timeEl.disabled = !needsTime;
    if(!needsTime) timeEl.value = "";
  }
}

function recolor(){
  board.querySelectorAll("tbody tr").forEach(tr=>{
    tr.dataset.status = tr.querySelector('select[name="status"]').value;
  });
}

function toast(msg){
  const t=toastEl; t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),1000);
}

/* ============================================================
 *  ログインUI
 * ============================================================ */
const loginEl  = document.getElementById('login');
const pwInput  = document.getElementById('pw');
const loginMsg = document.getElementById('loginMsg');
function showLogin(msg=""){ loginEl.style.display='flex'; loginMsg.textContent = msg || ""; setTimeout(()=>pwInput?.focus(),50); }
function hideLogin(){ loginEl.style.display='none'; loginMsg.textContent=""; pwInput.value=""; }

/* ============================================================
 *  JSONP（キャッシュ回避+タイムアウト）
 * ============================================================ */
function jsonp(url, timeout=12000){
  return new Promise((resolve)=>{
    const cb = 'cb_'+Math.random().toString(36).slice(2);
    let done=false;
    const cleanup=(s)=>{ try{ delete window[cb]; }catch(_){} if(s){ if(s.remove){s.remove();} else if(s.parentNode){s.parentNode.removeChild(s);} } };
    const timer=setTimeout(()=>{ if(!done){ done=true; cleanup(script); resolve(null); } }, timeout);
    window[cb]=(data)=>{ if(done) return; done=true; clearTimeout(timer); cleanup(script); resolve(data); };
    const script=document.createElement('script');
    script.src = url + (url.includes('?')?'&':'?') + 'callback=' + cb + '&_=' + Date.now();
    script.onerror=()=>{ if(!done){ done=true; clearTimeout(timer); cleanup(script); resolve(null); } };
    document.body.appendChild(script);
  });
}

/* ============================================================
 *  認証 & 同期（renew実装あり）
 * ============================================================ */
let SESSION_TOKEN = "";
let lastPushed=0;

/* 設定のロード（updatedも取得） */
async function tryLoadGroupsFromServer(nocache=false){
  const url = `${REMOTE_ENDPOINT}?action=getConfig&key=${encodeURIComponent('presence-config')}&token=${encodeURIComponent(SESSION_TOKEN)}${nocache?'&nocache=1':''}`;
  const cfg = await jsonp(url);
  if(!cfg || cfg.error) throw new Error('config_load_failed');
  const groups = normalizeConfigClient(cfg);
  if(!groups.length) throw new Error('config_empty');
  GROUPS = groups;
  CONFIG_UPDATED = (typeof cfg.updated === 'number') ? cfg.updated : 0;
}

/* 設定の自動更新監視（updatedが増えたら再描画） */
let configWatchTimer = null;
function startConfigWatch(){
  if(configWatchTimer) clearInterval(configWatchTimer);
  configWatchTimer = setInterval(async ()=>{
    if(!SESSION_TOKEN) return;
    try{
      const url = `${REMOTE_ENDPOINT}?action=getConfig&key=presence-config&token=${encodeURIComponent(SESSION_TOKEN)}&nocache=1`;
      const cfg = await jsonp(url);
      if(cfg && !cfg.error && typeof cfg.updated === 'number' && cfg.updated > CONFIG_UPDATED){
        const prevState = getState();
        GROUPS = normalizeConfigClient(cfg);
        CONFIG_UPDATED = cfg.updated;
        render();
        applyState(prevState);  // id一致分は維持、新規/削除は差分反映
        toast('名簿を更新しました');
      }
    }catch(_){}
  }, CONFIG_POLL_MS);
}

async function login(pw){
  if(!REMOTE_ENDPOINT){ loginMsg.textContent="同期先が未設定です（REMOTE_ENDPOINT）"; return; }
  if(!pw || !pw.trim()){ loginMsg.textContent="パスワードを入力してください"; return; }
  loginMsg.textContent = "認証中…";
  const res = await jsonp(`${REMOTE_ENDPOINT}?action=login&password=${encodeURIComponent(pw)}`);
  if(res === null){ loginMsg.textContent = "通信エラー（GASの公開設定/URLを確認）"; return; }
  if(res && res.error === 'unauthorized'){ loginMsg.textContent = "パスワードが違います"; return; }
  if(res && res.token){
    SESSION_TOKEN = res.token;
    sessionStorage.setItem(SESSION_KEY, SESSION_TOKEN);
    hideLogin();
    toast('ログインしました');
    try{
      await tryLoadGroupsFromServer(true); // 初回はnocacheで確実に取得
    }catch(_){
      toast('設定の取得に失敗しました');
    }
    render();
    scheduleRenew(Number(res.exp)||TOKEN_DEFAULT_TTL);
    startRemoteSync(true);
    startConfigWatch();
  }else{
    loginMsg.textContent = "サーバ応答が不正です（login実装/デプロイ要確認）";
  }
}

function requireTokenOrLogin(){
  SESSION_TOKEN = sessionStorage.getItem(SESSION_KEY) || "";
  if(!SESSION_TOKEN){ showLogin(); return false; }
  return true;
}

async function pullRemote(){
  if(!requireTokenOrLogin()) return;

  const url = `${REMOTE_ENDPOINT}?action=get&key=${encodeURIComponent(REMOTE_KEY)}&token=${encodeURIComponent(SESSION_TOKEN)}`;
  const remote = await jsonp(url);
  if(!remote) return;
  if(remote.error){
    sessionStorage.removeItem(SESSION_KEY); SESSION_TOKEN="";
    showLogin("セッションが切れました。再ログインしてください。");
    return;
  }
  if(remote.data){
    applyState(remote.data);
    try{ localStorage.setItem(storeKey, JSON.stringify(Object.assign({}, getState(), remote.data))); }catch(_){}
  }
}

async function pushRemote(){
  if(!requireTokenOrLogin()) return;
  const payload = encodeURIComponent(JSON.stringify({updated:Date.now(), data:getStateForPush()}));
  const url = `${REMOTE_ENDPOINT}?action=set&key=${encodeURIComponent(REMOTE_KEY)}&data=${payload}&token=${encodeURIComponent(SESSION_TOKEN)}`;
  const res = await jsonp(url);
  if(res && res.error){
    sessionStorage.removeItem(SESSION_KEY); SESSION_TOKEN="";
    showLogin("セッションが切れました。再ログインしてください。");
  }
}

function pushRemoteThrottled(){ const now=Date.now(); if(now-lastPushed>1200){ lastPushed=now; pushRemote(); } }

function startRemoteSync(forcePull=false){
  const start = ()=>{ if(forcePull) pullRemote(); setInterval(()=>pullRemote(), REMOTE_POLL_MS + Math.floor(Math.random()*1000)); };
  const jitter = Math.floor(Math.random()*REMOTE_POLL_MS);
  setTimeout(start, jitter);

  document.addEventListener('visibilitychange', async ()=>{
    if(!document.hidden){
      pullRemote();
    }
  });
  window.addEventListener('focus', pullRemote);

  // 同一端末の別タブ反映
  window.addEventListener('storage', (e)=>{ if(e.key===storeKey && e.newValue){ try{ applyState(JSON.parse(e.newValue)); }catch(_){ } } });
}

/* ---- トークン更新（TTLの80%でrenew） ---- */
function scheduleRenew(expMs){
  if(tokenRenewTimer){ clearTimeout(tokenRenewTimer); tokenRenewTimer=null; }
  const delay = Math.max(10000, Math.floor(expMs * 0.8)); // 最短10秒の安全弁
  tokenRenewTimer = setTimeout(renewToken, delay);
}

async function renewToken(){
  if(!SESSION_TOKEN) return;
  const res = await jsonp(`${REMOTE_ENDPOINT}?action=renew&token=${encodeURIComponent(SESSION_TOKEN)}`);
  if(res && res.ok){
    const next = Number(res.exp) || TOKEN_DEFAULT_TTL;
    scheduleRenew(next);
  }else{
    sessionStorage.removeItem(SESSION_KEY); SESSION_TOKEN="";
    showLogin("セッションが切れました。再ログインしてください。");
  }
}

/* ============================================================
 *  起動
 * ============================================================ */
document.addEventListener('DOMContentLoaded', ()=>{
  window.__doLogin = () => login(pwInput.value);
  document.getElementById('btnLogin').addEventListener('click', window.__doLogin);
  pwInput.addEventListener('keypress', (e)=>{ if(e.key==='Enter') window.__doLogin(); });

  const existing = sessionStorage.getItem(SESSION_KEY);
  if(existing){
    SESSION_TOKEN = existing;
    hideLogin();
    (async ()=>{
      const ok = await jsonp(`${REMOTE_ENDPOINT}?action=renew&token=${encodeURIComponent(SESSION_TOKEN)}`);
      if(ok && ok.ok){
        scheduleRenew(Number(ok.exp)||TOKEN_DEFAULT_TTL);
        try{ await tryLoadGroupsFromServer(true); }catch(_){}
        render();
        startRemoteSync(true);
        startConfigWatch();
      }else{
        sessionStorage.removeItem(SESSION_KEY); SESSION_TOKEN="";
        showLogin();
      }
    })();
  }else{
    showLogin();
  }
});

/* JSエラーを画面表示（見落とし防止） */
window.addEventListener('error', e=>{
  toastEl.style.background='#c53030';
  toastEl.textContent='エラー: '+e.message; toastEl.classList.add('show');
});
</script>

<!-- 備考候補（datalist） -->
<datalist id="noteOptions">
  <option value="直出"></option>
  <option value="直帰"></option>
  <option value="直出/直帰"></option>
</datalist>
</body>
</html>
<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>在席確認表</title>
<style>
  /* =========================================
   * 幅・サイズの集中定義（ここだけ触ればOK）
   * ========================================= */
  :root{
    /* 基準幅（px） */
    --base-name:   120px;  /* 氏名 */
    --base-ext:     80px;  /* 内線 */
    --base-status: 380px;  /* ステータス */
    --base-time:   120px;  /* 戻り時間 */
    --base-note:   320px;  /* 備考 */

    /* 倍率 */
    --scale-name:   0.50;
    --scale-ext:    0.33;
    --scale-status: 0.75;
    --scale-time:   0.45;

    /* 安全最小幅 */
    --min-name:    90px;
    --min-ext:     64px;
    --min-status: 260px;
    --min-time:   100px;
    --min-note:   260px;

    /* 実効幅（最終列幅） */
    --w-name:   max(calc(var(--base-name)   * var(--scale-name)),   var(--min-name));
    --w-ext:    max(calc(var(--base-ext)    * var(--scale-ext)),    var(--min-ext));
    --w-status: max(calc(var(--base-status) * var(--scale-status)), var(--min-status));
    --w-time:   max(calc(var(--base-time)   * var(--scale-time)),   var(--min-time));
    --w-note:   max(var(--base-note), var(--min-note));

    /* パネル最小幅：列合計 + 余白 */
    --panel-min: calc(var(--w-name) + var(--w-ext) + var(--w-status) + var(--w-time) + var(--w-note) + 60px);

    --gap: 20px;

    /* 色 */
    --line:#d9d9d9; --head:#f1ece6; --bg:#fafafa;
    --present:#e8f6e8; --away:#fff3e6; --remote:#e8f0ff; --off:#f7e8ee; --home:#ffe8f0;
  }

  @media (max-width: 768px){
    :root{
      --min-name:   90px;
      --min-ext:    64px;
      --min-status: 280px;
      --min-time:   110px;
      --min-note:   240px;

      --w-name:   var(--min-name);
      --w-ext:    var(--min-ext);
      --w-status: var(--min-status);
      --w-time:   var(--min-time);
      --w-note:   var(--min-note);

      --panel-min: calc(var(--w-name) + var(--w-ext) + var(--w-status) + var(--w-time) + var(--w-note) + 40px);
      --gap: 12px;
    }
    /* iOSズーム防止 */
    select, input{ font-size:16px; }
  }

  body{font-family:"Segoe UI","Hiragino Kaku Gothic ProN",Meiryo,sans-serif;background:#fff;margin:16px}
  header{display:flex;gap:8px;align-items:center;justify-content:center;margin-bottom:12px;flex-wrap:wrap}
  header h1{font-size:14px;font-weight:600;color:#4a5568;margin:0;padding:.35rem .9rem;background:#dff1ff;border-radius:999px}
  .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}

  .board{
    display:grid;
    grid-template-columns: repeat(auto-fit, minmax(var(--panel-min), 1fr));
    gap: var(--gap);
  }

  .panel{border:1px solid var(--line);border-radius:6px;background:var(--bg);padding:8px;overflow:auto}
  .panel .title{font-weight:700;color:#6B7280;background:#f7f7f7;border:1px solid var(--line);
                border-radius:4px;padding:6px 8px;margin:0 0 6px 0;min-height:1.8em}

  table{width:100%;border-collapse:separate;border-spacing:0;table-layout:fixed}
  thead th{position:sticky;top:0;background:var(--head);font-weight:700}
  th,td{border:1px solid var(--line);padding:6px;font-size:14px}
  th{text-align:left}

  /* 列幅 */
  col.col-name   { width: var(--w-name); }
  col.col-ext    { width: var(--w-ext); }
  col.col-status { width: var(--w-status); }
  col.col-time   { width: var(--w-time); }
  col.col-note   { width: var(--w-note); }

  /* 入力UI */
  select,input[type="text"]{
    width:100%;box-sizing:border-box;padding:.3rem .35rem;border:1px solid var(--line);
    border-radius:4px;background:#fff;font-size:14px;appearance:auto;-webkit-appearance:auto
  }
  /* ▼重なり対策（仕様値） */
  td.status select{ padding-right:2.6em; }
  /* ステータス列の最小幅（列変数と13emの大きい方） */
  td.status{ min-width: max(var(--w-status), 13em); }

  /* 戻り時間：中央寄せ＆タブラー数字 */
  td.time select{ text-align-last:center; font-variant-numeric:tabular-nums; }

  /* ステータス色 */
  tr[data-status="在席"]{background:var(--present)}
  tr[data-status="外出"]{background:var(--away)}
  tr[data-status="休み"],tr[data-status="健康診断"],tr[data-status="コアドック"]{background:var(--off)}
  tr[data-status="帰宅"]{background:var(--home)}
  tr[data-status="在宅勤務"]{background:var(--remote)}
  tr[data-status="出張"],tr[data-status="研修"]{background:var(--away)}

  .toast{position:fixed;top:20px;right:20px;background:#333;color:#fff;padding:8px 12px;border-radius:4px;font-size:12px;opacity:0;transition:.25s;z-index:9999}
  .toast.show{opacity:1}

  .login{position:fixed;inset:0;background:rgba(0,0,0,.6);display:flex;align-items:center;justify-content:center;z-index:2000}
  .login .card{background:#fff;border-radius:8px;padding:20px;min-width:300px;max-width:90vw;text-align:center}
  .login .card h2{margin:.2rem 0 1rem}
  .login .card input{margin:.4rem 0}

  @media print{
    header,.toast,.login{display:none}
    body{margin:0}
    .board{gap:10px}
    th,td{font-size:12px;padding:4px}
  }

  /* 拡張のハンドル抑止 */
  .board [draggable], .board [role="separator"]{ display:none !important; }
</style>
</head>
<body>
  <header>
    <h1>在席確認表（同期対応）</h1>
  </header>

  <!-- ログイン（成功までは表を生成しない） -->
  <div id="login" class="login" style="display:none">
    <div class="card">
      <h2>在席確認表</h2>
      <p>パスワードを入力してください</p>
      <input type="password" id="pw" placeholder="Password" />
      <button id="btnLogin" onclick="window.__doLogin && window.__doLogin()">ログイン</button>
      <div id="loginMsg" style="color:#c53030;margin-top:8px" aria-live="polite"></div>
    </div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>
  <!-- ログイン後に初めて描画 -->
  <div id="board" class="board" style="display:none"></div>

<script>
/* ============================================================
 *  同期設定（JSONP / GASトークン認証）
 * ============================================================ */
const REMOTE_ENDPOINT = "https://script.google.com/macros/s/AKfycbzWn93KAqmoHeRPRdTgrOFZX0e7X06fH3iReM30YBaQx4mQaSBkQzIF9r_EC5OeVVIC/exec";
const REMOTE_KEY      = "presence-board-default";
const REMOTE_POLL_MS  = 30000;                // 定期取得：30秒
const SESSION_KEY     = "presence-session-token";

/* トークン更新：TTLの80%時点でrenew */
const TOKEN_DEFAULT_TTL = 3600000; // 60分（GAS側がexpを返さない場合の保険）
let tokenRenewTimer = null;

/* ============================================================
 *  名簿・グループ（GASから取得）＋自動更新検知
 * ============================================================ */
let GROUPS = [];             // サーバの presence-config をロードして埋める
const CONFIG_POLL_MS = 120000;          // 名簿チェック間隔：2分（適宜調整）
const storeKeyBase   = "presence-board-v2"; // ローカル保存キーの接頭
let   storeKey       = storeKeyBase;        // 名簿版ごとに差し替える
let   currentConfigId = "";                 // cfg.updated or hash

/* 旧/新形式をクライアント側で正規化 */
function normalizeConfigClient(cfg){
  // 旧形式: [ ["村田","今泉"], ["佐藤", ...] ]
  if(Array.isArray(cfg) && cfg.length && Array.isArray(cfg[0])){
    return cfg.map(arr=>({ title:"", members: arr.map(n=>({name:String(n||"")})) }));
  }
  // v2形式
  if(cfg && Array.isArray(cfg.groups)){
    return cfg.groups.map(g=>({
      title: typeof g.title==="string" ? g.title : "",
      members: Array.isArray(g.members) ? g.members.map(m=>({
        name: String((m && m.name) || ""),
        ext:  (m && m.ext) ? String(m.ext) : ""
      })) : []
    }));
  }
  return [];
}

/* 名簿ID（更新印）: updatedがあればそれ、無ければハッシュ */
function calcCfgId(cfg){
  if(cfg && typeof cfg.updated === "number") return String(cfg.updated);
  const s = JSON.stringify(cfg||{});
  let h = 5381; for(let i=0;i<s.length;i++){ h = ((h<<5)+h) ^ s.charCodeAt(i); }
  return String(h>>>0);
}

/* ============================================================
 *  定数
 * ============================================================ */
const STATUSES = ["在席","外出","休み","帰宅","在宅勤務","出張","研修","健康診断","コアドック"];
const CLEAR_ON = new Set(["在席","休み","帰宅","在宅勤務"]);   // 選択で戻り/備考をクリア

/* ============================================================
 *  レンダリング
 * ============================================================ */
const board  = document.getElementById('board');
const toastEl= document.getElementById('toast');

function timeOptions(){
  const opts=['<option value=""></option>'];
  for(let h=0;h<24;h++){
    for(let m=0;m<60;m+=30){
      const t=`${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
      opts.push(`<option value="${t}">${t}</option>`);
    }
  }
  return opts.join('');
}

function rowHtml(gIndex, rIndex, member){
  const m   = (typeof member === 'string') ? {name: member} : (member || {});
  const name= m.name || "";
  const ext = (m.ext && /^[0-9]{1,4}$/.test(String(m.ext))) ? String(m.ext) : "";
  const key = `${gIndex}-${rIndex}`;
  return `
    <tr id="row-${key}" data-key="${key}" data-status="在席">
      <td class="name">${name}</td>
      <td class="ext">
        <label class="sr-only" for="ext-${key}">内線</label>
        <input id="ext-${key}" name="ext" type="text" maxlength="4"
               inputmode="numeric" pattern="^[0-9]{0,4}$" placeholder="内線"
               value="${ext}" />
      </td>
      <td class="status">
        <label class="sr-only" for="status-${key}">ステータス</label>
        <select id="status-${key}" name="status">
          ${STATUSES.map(s=>`<option value="${s}">${s}</option>`).join("")}
        </select>
      </td>
      <td class="time">
        <label class="sr-only" for="time-${key}">戻り時間</label>
        <select id="time-${key}" name="time">${timeOptions()}</select>
      </td>
      <td class="note">
        <input id="note-${key}" name="note" type="text" list="noteOptions" placeholder="備考" />
      </td>
    </tr>`;
}

function panelHtml(gIndex, group){
  return `
    <section class="panel">
      <h3 class="title">${group.title ?? ""}</h3>
      <table aria-label="在席表">
        <colgroup>
          <col class="col-name">
          <col class="col-ext">
          <col class="col-status">
          <col class="col-time">
          <col class="col-note">
        </colgroup>
        <thead>
          <tr><th>氏名</th><th>内線</th><th>ステータス</th><th>戻り時間</th><th>備考</th></tr>
        </thead>
        <tbody>${group.members.map((m,i)=>rowHtml(gIndex,i,m)).join("")}</tbody>
      </table>
    </section>`;
}

function render(){
  board.innerHTML = GROUPS.map((g,i)=>panelHtml(i,g)).join('');
  board.style.display = '';   // ログイン後に表示
  wireEvents();
  loadLocal();  // 端末ローカルの前回値を適用（名簿版ごとに独立）
  recolor();
}

/* ============================================================
 *  状態 I/O
 * ============================================================ */
function getState(){
  const data={};
  board.querySelectorAll("tbody tr").forEach(tr=>{
    const k=tr.dataset.key;
    data[k]={
      ext:    tr.querySelector('input[name="ext"]').value.trim(),
      status: tr.querySelector('select[name="status"]').value,
      time:   tr.querySelector('select[name="time"]').value,
      note:   tr.querySelector('input[name="note"]').value
    };
  });
  return data;
}

/* ローカル保存 */
function saveLocal(){ try{ localStorage.setItem(storeKey, JSON.stringify(getState())); toast('保存しました'); }catch(_){} }
function loadLocal(){ try{ const raw=localStorage.getItem(storeKey); if(!raw) return; applyState(JSON.parse(raw)); }catch(_){} }

/* 送信用：既定(在席/空欄)は送らない */
function getStateForPush(){
  const full=getState(), slim={};
  for(const [k,v] of Object.entries(full)){
    if(v.ext || v.status!=="在席" || v.time || (v.note && v.note.trim()!=="")) slim[k]=v;
  }
  return slim;
}

function applyState(data){
  if(!data) return;
  Object.entries(data).forEach(([k,v])=>{
    const e=document.getElementById(`ext-${k}`);
    const s=document.getElementById(`status-${k}`);
    const t=document.getElementById(`time-${k}`);
    const n=document.getElementById(`note-${k}`);
    if(e && typeof v.ext==="string") e.value = v.ext;
    if(s && v.status && STATUSES.includes(v.status)) s.value=v.status;
    if(t) t.value = v.time || "";
    if(n) n.value = v.note || "";
    if(s && t) toggleTimeEnable(s);
  });
  recolor();
}

/* ============================================================
 *  イベント
 * ============================================================ */
function wireEvents(){
  // 変更→保存→同期
  board.querySelectorAll("select,input").forEach(el=>{
    el.addEventListener("change", ()=>{
      if(el.name==="status"){
        const key = el.id.replace("status-","");
        const time = document.getElementById(`time-${key}`);
        const note = document.getElementById(`note-${key}`);
        if(CLEAR_ON.has(el.value)){
          if(time){ time.value=""; }
          if(note){ note.value=""; }
        }
        toggleTimeEnable(el);
      }
      saveLocal(); pushRemoteThrottled();
      recolor();
    });
  });
}

function toggleTimeEnable(statusEl){
  const key = statusEl.id.replace("status-","");
  const timeEl = document.getElementById(`time-${key}`);
  const needsTime = ["外出","出張","研修"].includes(statusEl.value);
  if(timeEl){
    timeEl.disabled = !needsTime;
    if(!needsTime) timeEl.value = "";
  }
}

function recolor(){
  board.querySelectorAll("tbody tr").forEach(tr=>{
    tr.dataset.status = tr.querySelector('select[name="status"]').value;
  });
}

function toast(msg){
  const t=toastEl; t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),1000);
}

/* ============================================================
 *  ログインUI
 * ============================================================ */
const loginEl  = document.getElementById('login');
const pwInput  = document.getElementById('pw');
const loginMsg = document.getElementById('loginMsg');
function showLogin(msg=""){ loginEl.style.display='flex'; loginMsg.textContent = msg || ""; setTimeout(()=>pwInput?.focus(),50); }
function hideLogin(){ loginEl.style.display='none'; loginMsg.textContent=""; pwInput.value=""; }

/* ============================================================
 *  JSONP（キャッシュ回避+タイムアウト）
 * ============================================================ */
function jsonp(url, timeout=12000){
  return new Promise((resolve)=>{
    const cb = 'cb_'+Math.random().toString(36).slice(2);
    let done=false;
    const cleanup=(s)=>{ try{ delete window[cb]; }catch(_){} if(s){ if(s.remove){s.remove();} else if(s.parentNode){s.parentNode.removeChild(s);} } };
    const timer=setTimeout(()=>{ if(!done){ done=true; cleanup(script); resolve(null); } }, timeout);
    window[cb]=(data)=>{ if(done) return; done=true; clearTimeout(timer); cleanup(script); resolve(data); };
    const script=document.createElement('script');
    script.src = url + (url.includes('?')?'&':'?') + 'callback=' + cb + '&_=' + Date.now();
    script.onerror=()=>{ if(!done){ done=true; clearTimeout(timer); cleanup(script); resolve(null); } };
    document.body.appendChild(script);
  });
}

/* ============================================================
 *  認証 & 同期（renew実装あり）
 * ============================================================ */
let SESSION_TOKEN = "";
let lastPushed=0;

/* 名簿ロード（変更有無を返す） */
async function tryLoadGroupsFromServer(){
  const url = `${REMOTE_ENDPOINT}?action=getConfig&key=${encodeURIComponent('presence-config')}&token=${encodeURIComponent(SESSION_TOKEN)}`;
  const cfg = await jsonp(url);
  if(!cfg || cfg.error){ throw new Error('config_load_failed'); }
  const groups = normalizeConfigClient(cfg);
  if(!groups.length){ throw new Error('config_empty'); }
  const newId = calcCfgId(cfg);
  const changed = (newId !== currentConfigId);
  currentConfigId = newId;
  storeKey = `${storeKeyBase}::${currentConfigId}`;  // 名簿版ごとに分離
  GROUPS = groups;
  return changed;
}

async function login(pw){
  if(!REMOTE_ENDPOINT){ loginMsg.textContent="同期先が未設定です（REMOTE_ENDPOINT）"; return; }
  if(!pw || !pw.trim()){ loginMsg.textContent="パスワードを入力してください"; return; }
  loginMsg.textContent = "認証中…";
  const res = await jsonp(`${REMOTE_ENDPOINT}?action=login&password=${encodeURIComponent(pw)}`);
  if(res === null){ loginMsg.textContent = "通信エラー（GASの公開設定/URLを確認）"; return; }
  if(res && res.error === 'unauthorized'){ loginMsg.textContent = "パスワードが違います"; return; }
  if(res && res.token){
    SESSION_TOKEN = res.token;
    sessionStorage.setItem(SESSION_KEY, SESSION_TOKEN);
    hideLogin();
    toast('ログインしました');
    // サーバ設定を取得してから描画
    try{
      await tryLoadGroupsFromServer();
    }catch(_){
      toast('設定の取得に失敗しました');
    }
    render();
    scheduleRenew(Number(res.exp)||TOKEN_DEFAULT_TTL);
    startRemoteSync(true);
    startConfigWatch();                     // ★名簿自動監視開始
  }else{
    loginMsg.textContent = "サーバ応答が不正です（login実装/デプロイ要確認）";
  }
}

function requireTokenOrLogin(){
  SESSION_TOKEN = sessionStorage.getItem(SESSION_KEY) || "";
  if(!SESSION_TOKEN){ showLogin(); return false; }
  return true;
}

async function pullRemote(){
  if(!requireTokenOrLogin()) return;

  // 初回/復帰時にconfigが未ロードなら取りに行く
  if(!GROUPS.length){
    try{ await tryLoadGroupsFromServer(); render(); }catch(_){}
  }

  const url = `${REMOTE_ENDPOINT}?action=get&key=${encodeURIComponent(REMOTE_KEY)}&token=${encodeURIComponent(SESSION_TOKEN)}`;
  const remote = await jsonp(url);
  if(!remote) return;
  if(remote.error){
    sessionStorage.removeItem(SESSION_KEY); SESSION_TOKEN="";
    showLogin("セッションが切れました。再ログインしてください。");
    return;
  }
  if(remote.data){
    applyState(remote.data);
    try{ localStorage.setItem(storeKey, JSON.stringify(Object.assign({}, getState(), remote.data))); }catch(_){}
  }
}

async function pushRemote(){
  if(!requireTokenOrLogin()) return;
  const payload = encodeURIComponent(JSON.stringify({updated:Date.now(), data:getStateForPush()}));
  const url = `${REMOTE_ENDPOINT}?action=set&key=${encodeURIComponent(REMOTE_KEY)}&data=${payload}&token=${encodeURIComponent(SESSION_TOKEN)}`;
  const res = await jsonp(url);
  if(res && res.error){
    sessionStorage.removeItem(SESSION_KEY); SESSION_TOKEN="";
    showLogin("セッションが切れました。再ログインしてください。");
  }
}

function pushRemoteThrottled(){ const now=Date.now(); if(now-lastPushed>1200){ lastPushed=now; pushRemote(); } }

function startRemoteSync(forcePull=false){
  const start = ()=>{ if(forcePull) pullRemote(); setInterval(()=>pullRemote(), REMOTE_POLL_MS + Math.floor(Math.random()*1000)); };
  const jitter = Math.floor(Math.random()*REMOTE_POLL_MS);
  setTimeout(start, jitter);

  document.addEventListener('visibilitychange', async ()=>{
    if(!document.hidden){
      if(!GROUPS.length){ try{ await tryLoadGroupsFromServer(); render(); }catch(_){} }
      pullRemote();
    }
  });
  window.addEventListener('focus', pullRemote);

  // 同一端末の別タブ反映
  window.addEventListener('storage', (e)=>{ if(e.key===storeKey && e.newValue){ try{ applyState(JSON.parse(e.newValue)); }catch(_){ } } });
}

/* ---- 名簿ウォッチ（cfg.updatedが変わったら再描画） ---- */
function startConfigWatch(){
  const tick = async ()=>{
    if(!SESSION_TOKEN) return;
    try{
      const changed = await tryLoadGroupsFromServer();
      if(changed){
        render();
        toast('名簿が更新されました');
        pullRemote(); // 在席データも最新へ
      }
    }catch(_){/* 無視 */ }
  };
  setTimeout(tick, Math.floor(Math.random()*5000));
  setInterval(tick, CONFIG_POLL_MS + Math.floor(Math.random()*3000));
}

/* ---- トークン更新（TTLの80%でrenew） ---- */
function scheduleRenew(expMs){
  if(tokenRenewTimer){ clearTimeout(tokenRenewTimer); tokenRenewTimer=null; }
  const delay = Math.max(10000, Math.floor(expMs * 0.8)); // 最短10秒の安全弁
  tokenRenewTimer = setTimeout(renewToken, delay);
}

async function renewToken(){
  if(!SESSION_TOKEN) return;
  const res = await jsonp(`${REMOTE_ENDPOINT}?action=renew&token=${encodeURIComponent(SESSION_TOKEN)}`);
  if(res && res.ok){
    const next = Number(res.exp) || TOKEN_DEFAULT_TTL;
    scheduleRenew(next);
  }else{
    sessionStorage.removeItem(SESSION_KEY); SESSION_TOKEN="";
    showLogin("セッションが切れました。再ログインしてください。");
  }
}

/* ============================================================
 *  起動
 * ============================================================ */
document.addEventListener('DOMContentLoaded', ()=>{
  window.__doLogin = () => login(pwInput.value);
  document.getElementById('btnLogin').addEventListener('click', window.__doLogin);
  pwInput.addEventListener('keypress', (e)=>{ if(e.key==='Enter') window.__doLogin(); });

  const existing = sessionStorage.getItem(SESSION_KEY);
  if(existing){
    SESSION_TOKEN = existing;
    hideLogin();
    // 既存セッションなら設定の先取り取得→描画→同期
    (async ()=>{
      const ok = await jsonp(`${REMOTE_ENDPOINT}?action=renew&token=${encodeURIComponent(SESSION_TOKEN)}`);
      if(ok && ok.ok){
        scheduleRenew(Number(ok.exp)||TOKEN_DEFAULT_TTL);
        try{ await tryLoadGroupsFromServer(); }catch(_){}
        render();
        startRemoteSync(true);
        startConfigWatch();           // ★既存セッションでも監視開始
      }else{
        sessionStorage.removeItem(SESSION_KEY); SESSION_TOKEN="";
        showLogin();
      }
    })();
  }else{
    showLogin();
  }
});

/* JSエラーを画面表示（見落とし防止） */
window.addEventListener('error', e=>{
  toastEl.style.background='#c53030';
  toastEl.textContent='エラー: '+e.message; toastEl.classList.add('show');
});
</script>

<!-- 備考候補（B方式：datalist一体型） -->
<datalist id="noteOptions">
  <option value="直出"></option>
  <option value="直帰"></option>
  <option value="直出/直帰"></option>
</datalist>
</body>
</html>







